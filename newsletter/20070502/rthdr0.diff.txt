Index: ip6_input.c
===================================================================
RCS file: /cvsroot/kame/kame/kame/sys/netinet6/ip6_input.c,v
retrieving revision 1.370
retrieving revision 1.371
diff -u -r1.370 -r1.371
--- ip6_input.c	8 Apr 2007 17:04:31 -0000	1.370
+++ ip6_input.c	3 May 2007 22:07:39 -0000	1.371
@@ -1,4 +1,4 @@
-/*	$KAME: ip6_input.c,v 1.370 2007/04/08 17:04:31 jinmei Exp $	*/
+/*	$KAME: ip6_input.c,v 1.371 2007/05/03 22:07:39 itojun Exp $	*/
 
 /*
  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
@@ -375,7 +375,7 @@
 	int off = sizeof(struct ip6_hdr), nest;
 	u_int32_t plen;
 	u_int32_t rtalert = ~0;
-	int nxt, ours = 0;
+	int nxt, ours = 0, rh_present = 0;
 	struct ifnet *deliverifp = NULL;
 #if 0
 	struct mbuf *mhist;	/* onion peeling history */
@@ -1056,9 +1056,11 @@
 	in6_ifstat_inc(deliverifp, ifs6_in_deliver);
 	nest = 0;
 
+	rh_present = 0;
 	while (nxt != IPPROTO_DONE) {
 		if (ip6_hdrnestlimit && (++nest > ip6_hdrnestlimit)) {
 			ip6stat.ip6s_toomanyhdr++;
+			in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_hdrerr);
 			goto bad;
 		}
 
@@ -1088,6 +1090,15 @@
 		}
 #endif
 
+		if (nxt == IPPROTO_ROUTING) {
+			if (rh_present++) {
+				in6_ifstat_inc(m->m_pkthdr.rcvif,
+				    ifs6_in_hdrerr);
+				ip6stat.ip6s_badoptions++;
+				goto bad;
+			}
+		}
+
 #if defined(IPSEC) && !defined(__OpenBSD__)
 		/*
 		 * enforce IPsec policy checking if we are seeing last header.
Index: route6.c
===================================================================
RCS file: /cvsroot/kame/kame/kame/sys/netinet6/route6.c,v
retrieving revision 1.60
retrieving revision 1.63
diff -u -r1.60 -r1.63
--- route6.c	25 Jun 2006 02:21:47 -0000	1.60
+++ route6.c	5 May 2007 10:11:49 -0000	1.63
@@ -1,4 +1,4 @@
-/*	$KAME: route6.c,v 1.60 2006/06/25 02:21:47 jinmei Exp $	*/
+/*	$KAME: route6.c,v 1.63 2007/05/05 10:11:49 itojun Exp $	*/
 
 /*
  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
@@ -62,8 +62,10 @@
 
 #include <netinet/icmp6.h>
 
+#if 0
 static int ip6_rthdr0 __P((struct mbuf *, struct ip6_hdr *,
     struct ip6_rthdr0 *));
+#endif
 
 #if defined(MIP6) && NMIP > 0
 static int ip6_rthdr2 __P((struct mbuf *, struct ip6_hdr *,
@@ -106,6 +108,22 @@
 #endif
 
 	switch (rh->ip6r_type) {
+#if 0
+	/*
+	 * See http://www.secdev.org/conf/IPv6_RH_security-csw07.pdf
+	 * for why IPV6_RTHDR_TYPE_0 is baned here.
+	 *
+	 * We return ICMPv6 parameter problem so that innocent people
+	 * (not an attacker) would notice about the use of IPV6_RTHDR_TYPE_0.
+	 * Since there's no amplification, and ICMPv6 error will be rate-
+	 * controlled, it shouldn't cause any problem.
+	 * If you are concerned about this, you may want to use the following
+	 * code fragment:
+	 *
+	 * case IPV6_RTHDR_TYPE_0:
+	 *	m_freem(m);
+	 *	return (IPPROTO_DONE);
+	 */
 	case IPV6_RTHDR_TYPE_0:
 		rhlen = (rh->ip6r_len + 1) << 3;
 		if (rh->ip6r_segleft == 0)
@@ -135,6 +153,7 @@
 		if (ip6_rthdr0(m, ip6, (struct ip6_rthdr0 *)rh))
 			return (IPPROTO_DONE);
 		break;
+#endif
 #if defined(MIP6) && NMIP > 0
 	case IPV6_RTHDR_TYPE_2:
 		rhlen = (rh->ip6r_len + 1) << 3;
@@ -170,6 +189,7 @@
 	return (rh->ip6r_nxt);
 }
 
+#if 0
 /*
  * Type0 routing header processing
  *
@@ -260,6 +280,7 @@
 	m_freem(m);
 	return (-1);
 }
+#endif
 
 #if defined(MIP6) && NMIP > 0
 /* Type2 routing header processing */
